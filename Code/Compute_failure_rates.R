#################################################################################
# PQ failure rates: sum(per-person probabilities of any failure) / people, where
# people are all PQ treated, and the per-person probability of any failure is 1
# minus the per-recurrence product of reinfection. Estimates based on
# time-to-event only are used where genetically informed estimates are not
# available and for censored observations. The code is based on
# Pooled_Analysis.Rmd but it differs (see notes below).
# 
# Because genetic data on BPD study participants were all analysed jointly under
# the prototype, for BPD failure rate computations using the old results, we can
# compute an estimate using both the old median and mean (they are not equal -
# see plot in Extract_and_plot_prototype.R). Besides supplementary figure 9,
# almost all figures and computations in Pooled_Analysis.Rmd and thus the
# Taylor&Watson 2019 are based on the median. This includes the PQ failure rate
# computations. The re-estimate based on the old mean is computed to see how
# old-median vs old-mean compares with old-median vs new-mean for BPD. The
# statistical genetic focus of the re-analysis does not merit the heavy
# computation required for a new median. Note that Pv3Rs results also differ to
# prototype ones because they use slightly different allele frequencies, and the
# time-to-event posterior estimates plugged into the prototype were
# un-normalised - we retain the use of un-normalised prior estimates when
# re-computing the old median estimate to internally check the failure rate
# computation, but use of normalised ones makes negligible difference: 
# Internal check of BPD Failure rate: 
# 3.047353 on line 2008 of Pooled_Analysis.Rmd
# 3.047353 if based on prior_unnorm here
# 3.047317 if based on prior here
################################################################################
rm(list = ls())
Figs <- TRUE
outlier_correction <- TRUE

# Load Pv3R results
load("../RData/marg_results_Pv3Rs.RData") 

# Load VHX and BPD pooled non-genetic data set and convert to data frame
load('../jwatowatson-RecurrentVivax-4870715/RData/TimingModel/Combined_Time_Event.RData')

# Remove enrolment episodes, add episode ids
Combined_Time_Data <- as.data.frame(Combined_Time_Data)
Combined_Time_Data <- Combined_Time_Data[Combined_Time_Data$episode > 1, ]
Combined_Time_Data$episodeid <- paste(Combined_Time_Data$patientid,
                                          Combined_Time_Data$episode, sep = "_")

# Extract reinfection probabilities for all recurrences and censored rows.
# N.B. censored rows have pseudo episode numbers and "1" under censored.
Combined_Time_Data$I_prototype_median <- NA
Combined_Time_Data$I_prototype_mean <- NA
Combined_Time_Data$I_Pv3Rs <- NA

# Load genetic-based median estimates for all analysed by prototype (jointly or pairwise)
load("../Rdata/MS_final_generated_by_running_all_chunks_of_Pooled_Analysis.Rmd")
rownames(MS_final) <- MS_final[,"Episode_Identifier"]

# Load genetic-based median and mean estimates for for all analysed jointly by prototype
path <- "../jwatowatson-RecurrentVivax-4870715/" # Path to old estimates
load(sprintf('%sRData/GeneticModel/Including_Complex_Cases_Full_Posterior_Model_samples.RData', path))
# NB that theta_9MS contains rows for pids with NA estimates: 
rownames(thetas_9MS)[which(!rownames(thetas_9MS) %in% rownames(MS_final))]
thetas_9MS[which(!rownames(thetas_9MS) %in% rownames(MS_final)),]

# Check prototype median estimates agree over old datasets where overlap
all(MS_final[row.names(thetas_9MS), "I_median"] == thetas_9MS[, "I50%"], na.rm = T)

# Extract genetic based estimates generated by the prototype
prototype_median <- MS_final$I_median
prototype_mean <- thetas_9MS[rownames(MS_final), "I"] 
names(prototype_median) <- names(prototype_mean) <- rownames(MS_final)

# Check prototype mean estimates were extracted correctly; na.rm because of NAs mentioned above
all(prototype_mean[rownames(thetas_9MS)] == thetas_9MS[, "I"], na.rm = T)

# Collect prototype and Pv3Rs results within a single data frame
if(!all(names(prototype_mean) == names(prototype_median))) stop ("Problem with eids")
Results <- data.frame(Pv3Rs = TimeToEvent_Pv3Rs[,"I"], 
                          prototype_median[rownames(TimeToEvent_Pv3Rs)], 
                          prototype_mean[rownames(TimeToEvent_Pv3Rs)])
rownames(Results) <- rownames(TimeToEvent_Pv3Rs)
nrow(Results) # Should be 493

if(outlier_correction){
  Results["BPD_577_2", "Pv3Rs"] <- 0 # Prior on reinfection is high
  Results["VHX_56_2", "Pv3Rs"] <- 0 # Prior on reinfection is near zero
}

# Load time-to-event only based estimates. These are all posterior mean
# estimates (Pooled_Analysis.Rmd lines 672 and 1807). prior_estimates.RData
# is generated by Compute_recurrent_states_Pv3Rs.R
load("../RData/prior_estimates.RData")
# Check prior row names are the same ahead of for loop below
if (!all(rownames(prior_unnorm) == rownames(prior))) stop("prior row-name mismatch")

# ==============================================================================
# Populate Combined_Time_Data in order to compute failure rates
# ==============================================================================
# Replace NA with genetic-based estimate where available; use time-to-event
# otherwise (includes all censored rows). N.B. BPD_634_3 and BPD_68_4 are
# missing time-to-event estimates. N.B. In Pool_Analysis.Rmd, probabilities are
# stored in rows for episode 1 to final recurrences ("we look one episode ahead"
# - line 1787). Here, probabilities are stored in rows for initial recurrence to
# censored row.
for(i in 1:nrow(Combined_Time_Data)){

  eid <- Combined_Time_Data$episodeid[i]

  if (eid %in% rownames(Results)) { # Use genetic episode if available
    j <- which(rownames(Results) == eid)
    Combined_Time_Data$I_prototype_median[i] <- Results$prototype_median[j]
    Combined_Time_Data$I_prototype_mean[i] <- Results$prototype_mean[j]
    Combined_Time_Data$I_Pv3Rs[i] <- Results$Pv3Rs[j]
    # Else if needed because BPD_634_3 and BPD_68_4 miss time-to-event estimates:
  } else if (eid %in% rownames(prior)) { 
    j <- which(rownames(prior) == eid)
    # Use un-normalised for median because median used for internal check.
    Combined_Time_Data$I_prototype_median[i] <- prior_unnorm$I[j]
    Combined_Time_Data$I_prototype_mean[i] <- prior$I[j]
    Combined_Time_Data$I_Pv3Rs[i] <- prior$I[j]
  }
}


# FYI, among people without recurrences, early drop outs have higher failure estimates
No_recurrence_logs <- !Combined_Time_Data$episodeid %in% rownames(Results)
No_recurrence_eids <- Combined_Time_Data$episodeid[No_recurrence_logs]
plot(x = Combined_Time_Data[No_recurrence_logs, "Time_to_event"],
     y = 1-prior[No_recurrence_eids, "I"], pch = 4, 
     col = grepl("PMQ", Combined_Time_Data$arm_num[No_recurrence_logs]) + 2)
legend("right", legend = c("no PMQ", "PMQ+"), fill = (0:1)+2, bty = "n")

# Create a per-patient summary data frame (remove episode-level summaries to
# avoid confusion - should have done this in Pooled_Analysis.Rmd)
patient_summaries = Combined_Time_Data[!duplicated(Combined_Time_Data$patientid),
                                               c("patientid", "arm_num", "FU_time")]
patient_summaries$Failure_prototype_median <- NA
patient_summaries$Failure_prototype_mean <- NA
patient_summaries$Failure_Pv3Rs <- NA
 
# Compute PQ per-participant failure probabilities
for(i in 1:nrow(patient_summaries)){
  pid = patient_summaries$patientid[i]
  ind = which(pid == Combined_Time_Data$patientid)
  patient_summaries$Failure_prototype_median[i] <- 1-prod(Combined_Time_Data[ind, "I_prototype_median"], na.rm = T)
  patient_summaries$Failure_prototype_mean[i] <- 1-prod(Combined_Time_Data[ind, "I_prototype_mean"], na.rm = T)
  patient_summaries$Failure_Pv3Rs[i] <- 1-prod(Combined_Time_Data[ind, "I_Pv3Rs"], na.rm = T)
}

# ==============================================================================
# Recompute study-level failure rate estimates, checking prototype_median agrees
# with Pooled_Analysis (internal control). Old results: 3% for BPD PQ treated
# (all BPD patients), 2.4% for VHX PQ treated, 2.9% for BPD plus VHX PQ treated,
# based on median. Specifically, 3.047353 for BPD computed on line 2008 of
# Pooled_Analysis.Rmd, based on the median reinfection probability (see lines
# 1791 and 1792).
# ==============================================================================

# Logicals for PQ treated individuals
ind_all <- grepl("PMQ", patient_summaries$arm_num) 
ind_BPD <- grepl("PMQ", patient_summaries$arm_num) & grepl("BPD", patient_summaries$patientid)
ind_VHX <- grepl("PMQ", patient_summaries$arm_num) & grepl("VHX", patient_summaries$patientid)

# All patients have estimates based either on time-to-event only or
# time-to-event plus genetic data; among estimates generated by Pv3Rs but not
# the prototype, only one recurrence (VHX_583_2) was in a PMQ treated
# individual; genetic data on VHX_583_3 was analysed by the prototype
any(is.na(patient_summaries$Failure_prototype_median[ind_all]))
any(is.na(patient_summaries$Failure_prototype_mean[ind_all]))
any(is.na(patient_summaries$Failure_Pv3Rs[ind_all]))

Failure_prototype = 100*sum(patient_summaries$Failure_prototype_median[ind_all], na.rm = T)/sum(ind_all)
Failure_Pv3Rs = 100*sum(patient_summaries$Failure_Pv3Rs[ind_all], na.rm = T)/sum(ind_all)

Failure_prototype_BPD_median = 100*sum(patient_summaries$Failure_prototype_median[ind_BPD], na.rm = T)/sum(ind_BPD)
Failure_prototype_BPD_mean = 100*sum(patient_summaries$Failure_prototype_mean[ind_BPD], na.rm = T)/sum(ind_BPD)
Failure_Pv3Rs_BPD = 100*sum(patient_summaries$Failure_Pv3Rs[ind_BPD], na.rm = T)/sum(ind_BPD)

Failure_prototype_VHX = 100*sum(patient_summaries$Failure_prototype_median[ind_VHX], na.rm = T)/sum(ind_VHX)
Failure_Pv3Rs_VHX = 100*sum(patient_summaries$Failure_Pv3Rs[ind_VHX], na.rm = T)/sum(ind_VHX)

BPD = c(Failure_prototype_BPD_median, Failure_Pv3Rs_BPD)
VHX = c(Failure_prototype_VHX, Failure_Pv3Rs_VHX)
All = c(Failure_prototype, Failure_Pv3Rs)

# Unrounded for self; rounded for ms
cbind(BPD, VHX, All) # 3.047353 for BPD computed on line 2008 of Pooled_Analysis.Rmd
round(cbind(BPD, VHX, All), 2)

# NB the high Pv3Rs failure rate of how the low Pv3Rs failure rate of VHX_56 (half-sib Pv3Rs misspecification) is compensated for by the high failure rate for VHX_583
patient_summaries[patient_summaries$patientid %in% c("VHX_583", "VHX_56"), ]
diffs <- patient_summaries$Failure_prototype_median - patient_summaries$Failure_Pv3Rs
big_diffs <- abs(diffs) > 0.25
if (Figs) png(sprintf("../Figures/compare_failure_rates_outlier_corrected_%s.png", outlier_correction),
    width = 7, height = 7, units = "in", res = 300)
plot(x = patient_summaries$Failure_prototype_median[ind_all], 
     y = patient_summaries$Failure_Pv3Rs[ind_all],
     xlab = "Prototype", ylab = "Pv3Rs", bty = "n", 
     xlim = c(0,1.15), ylim = c(0,1.15),
     pch = 16 + grepl("VHX", patient_summaries$patientid))
text(x = patient_summaries$Failure_prototype_median[ind_all][big_diffs[ind_all]], 
     y = patient_summaries$Failure_Pv3Rs[ind_all][big_diffs[ind_all]], 
     labels = patient_summaries$patientid[ind_all][big_diffs[ind_all]], 
     pos = 4)
legend("left", pch = 16:17, bty = "n",
       legend = c("BPD study participant", "VHX study participant"), )
abline(a = 0, b = 1, lty = "dotted")
if(Figs) dev.off()

