#################################################################################
# PQ failure rates: sum(per-person probabilities of any failure) / people, where
# people are all PQ treated, and the per-person probability of any failure is 1
# minus the product of reinfection. Note that estimates based on time-to-event
# only are used where genetically informed estimates are not available and for
# censored observations.
#
# Old results: 3% for BPD PQ treated (all BPD patients), 2.4% for VHX PQ
# treated, 2.9% for BPD plus VHX PQ treated, based on median. We focus on BPD
# only here, because VHX genetic-based estimates require paired-episode post-hoc
# analysis. Specifically, 3.047353 for BPD computed on line 2008 of
# Pooled_Analysis.Rmd, based on the median reinfection probability (see lines
# 1791 and 1792)
#
# Run this after Compare_recurrent_state.R.
#
# This code is based on Pooled_Analysis.Rmd but it differs (see notes below).
#
# Could-do:
# 1) Base new computation on median, with lower and upper credible intervals -
# requires extra computations, which are computationally expensive.

# Copied from Compare_recurrent_states.R (to sort)
# # Within the old results, we can either compare to the median or the mean (they
# are not equal - see plots below). Besides supplementary figure 9, almost all
# figures and computations in Pooled_Analysis.Rmd and thus the Taylor&Watson
# 2019 are based on the median. This includes the PQ failure rate computations.
# The old median is used to internally check failure rate
# computation. The old mean is then compared with the new mean - the new
# median is computationally expensive to re-estimate, with a small return on
# investment, especially if new estimates are not included in a manuscript. To
# extract both median and mean estimates for Compute_PQ_failure_rates_new.R, I
# thus loop over median and mean. This is suboptimal coding --- would have been
# better to save both median and mean in Results_BPD --- but it does the job
# (the time investment to optimise is non-negligible for a small return).
# 
# To ensure the only difference between new and old results is the updated
# model, we use the old allele frequencies and compare new results with those
# that were directly computed in Taylor & Watson et al. 2019. Those that were
# directly computed in Taylor & Watson et al. 2019 exclude all those with data
# on more than three episodes (default argument Max_Eps = 3 of function
# post_prob_CLI). For three of nine patients whose data were analysed when
# EXCLUDE_COMPLEX = F (the option to exclude these patients was set to aid
# illustrative runs of the code), NAs were returned. That said, results
# generated using the time-to-event posterior estimates as prior estimates also
# differ because prior estimates plugged into the old model were un-normalised
# but are normalised here.
################################################################################
rm(list = ls())

# Load VHX and BPD pooled non-genetic data set and convert to data frame
load('~/Documents/RecurrentVivax/RData/TimingModel/Combined_Time_Event.RData')

# Focus on BPD, remove enrolment episodes, add episode ids
Combined_Time_Data <- as.data.frame(Combined_Time_Data)
Combined_Time_Data_BPD <- Combined_Time_Data[grepl("BPD", Combined_Time_Data$patientid), ]
Combined_Time_Data_BPD <- Combined_Time_Data_BPD[Combined_Time_Data_BPD$episode > 1, ]
Combined_Time_Data_BPD$episodeid <- paste(Combined_Time_Data_BPD$patientid,
                                          Combined_Time_Data_BPD$episode, sep = "_")

# Extract reinfection probabilities for all recurrences and censored rows.
# N.B. censored rows have have pseudo episode numbers and "1" under censored.
Combined_Time_Data_BPD$I_old_median <- NA
Combined_Time_Data_BPD$I_old_mean <- NA
Combined_Time_Data_BPD$I_new <- NA
Combined_Time_Data_BPD$I_gen <- 0

# Load genetic-based recurrent estimates for BPD and combine into Results_BPD.
# This is suboptimal coding --- would have been better to save both median and
# mean in Results_BPD --- but it does the job and the time investment to
# optimise is non-negligible for a small return.
path <- "~/Documents/RecurrentVivax" # Path to old estimates
load(sprintf('%s/RData/GeneticModel/Including_Complex_Cases_Full_Posterior_Model_samples.RData', path))
old_median <- thetas_9MS[, "I50%"] 
old_mean <- thetas_9MS[, "I"] 
names(old_median) <- names(old_mean) <- rownames(thetas_9MS)

# Load new results
load("../RData/marg_results_Pv3Rs.RData") 

if( !all(names(old_mean) == names(old_median)) ) stop ("Problem with eids")
Results_BPD <- data.frame(new = TimeToEvent_Pv3Rs[names(old_median),"I"], old_median, old_mean)
rownames(Results_BPD) <- names(old_mean)

# Load time-to-event only based estimates (used when genetic ones unavailable)
# These are all posterior mean estimates (Pooled_Analysis.Rmd lines 672 and 1807)
# N.B. prior_estimates.RData is generated by Compute_recurrent_states_new.R
load("~/Dropbox/Vivax_VHXBPD_reanalysis/RData/prior_estimates.RData")
# Check prior rownames are the same ahead of for loop below
if (!all(rownames(prior_unnorm) == rownames(prior))) stop("prior rowname mismatch")

# ==============================================================================
# Populate Combined_Time_Data_BPD in order to compute failure rates
# ==============================================================================
# Replace NA with genetic-based estimate where available; use time-to-event
# otherwise (includes all censored rows). N.B. BPD_634_3 and BPD_68_4 are
# missing time-to-event estimates. N.B. In Pool_Analysis.Rmd, probabilities are
# stored in rows for episode 1 to final recurrences ("we look one episode ahead"
# - line 1787). Here, probabilities are stored in rows for initial recurrence to
# censored row.
for(i in 1:nrow(Combined_Time_Data_BPD)){

  eid <- Combined_Time_Data_BPD$episodeid[i]

  if (eid %in% rownames(Results_BPD)) { # Use genetic episode if available
    j <- which(rownames(Results_BPD) == eid)
    Combined_Time_Data_BPD$I_old_median[i] <- Results_BPD$old_median[j]
    Combined_Time_Data_BPD$I_old_mean[i] <- Results_BPD$old_mean[j]
    Combined_Time_Data_BPD$I_new[i] <- Results_BPD$new[j]
    Combined_Time_Data_BPD$I_gen[i] <- 1 # Make a note that genetic-based
  } else if (eid %in% rownames(prior)) { # Needed because BPD_634_3 and BPD_68_4 are missing
    j <- which(rownames(prior) == eid)
    # Use un-normalised for median because median used for internal check.
    Combined_Time_Data_BPD$I_old_median[i] <- prior_unnorm$I[j]
    Combined_Time_Data_BPD$I_old_mean[i] <- prior$I[j]
    Combined_Time_Data_BPD$I_new[i] <- prior$I[j]
  }
}

# FYI, among people without recurrences, early drop outs have higher failure estimates
No_recurrence_logs <- !Combined_Time_Data_BPD$episodeid %in% rownames(Results_BPD)
No_recurrence_eids <- Combined_Time_Data_BPD$episodeid[No_recurrence_logs]
plot(x = Combined_Time_Data_BPD[No_recurrence_logs, "Time_to_event"],
     y = 1-prior[No_recurrence_eids, "I"])
head(sort(1-prior[No_recurrence_eids, "I"], decreasing = T))


which(rownames(Results_BPD) == eid)
prior$I[which(rownames(prior) == eid)]

# Create a per-patient summary data frame (remove episode-level summaries to
# avoid confusion - should have done this in Pooled_Analysis.Rmd)
BPD_patient_summaries = Combined_Time_Data_BPD[!duplicated(Combined_Time_Data_BPD$patientid),
                                               c("patientid", "arm_num", "FU_time")]
BPD_patient_summaries$Failure_old_median <- NA
BPD_patient_summaries$Failure_old_mean <- NA
BPD_patient_summaries$Failure_new <- NA
BPD_patient_summaries$Failure_gen <- NA

# Compute PQ failure probabilities
for(i in 1:nrow(BPD_patient_summaries)){
  pid = BPD_patient_summaries$patientid[i]
  ind = which(pid == Combined_Time_Data_BPD$patientid)
  BPD_patient_summaries$Failure_old_median[i] <- 1-prod(Combined_Time_Data_BPD[ind, "I_old_median"], na.rm = T)
  BPD_patient_summaries$Failure_old_mean[i] <- 1-prod(Combined_Time_Data_BPD[ind, "I_old_mean"], na.rm = T)
  BPD_patient_summaries$Failure_new[i] <- 1-prod(Combined_Time_Data_BPD[ind, "I_new"], na.rm = T)
  BPD_patient_summaries$Failure_gen[i] <- sum(Combined_Time_Data_BPD[ind, "I_gen"])
}

# ==============================================================================
# Recompute point estimate, checking old_mean one agrees with Pooled_Analysis
# (internal control). Specifically, P_Failure 3.047353 computed on line 2008 of
# Pooled_Analysis.Rmd, based on the median reinfection probability (see lines
# 1791 and 1792, where Combined_Time_Data$Reinfection_Probability[i] =
# MS_final$I_median[MS_final$Episode_Identifier==MS_id])
# ==============================================================================
P_Failure_old_median = 100*sum(BPD_patient_summaries$Failure_old_median, na.rm = T)/nrow(BPD_patient_summaries)
P_Failure_old_mean = 100*sum(BPD_patient_summaries$Failure_old_mean, na.rm = T)/nrow(BPD_patient_summaries)
P_Failure_new = 100*sum(BPD_patient_summaries$Failure_new, na.rm = T)/nrow(BPD_patient_summaries)

# New mean estimates give the same failure rate as old median estimates: new
# model just not change the scientific conclusion of Taylor&Watson et al. 2019
writeLines(sprintf('The PQ failure rate using the old median estimates is %s%% in %s individuals',
                   round(P_Failure_old_median, 6), nrow(BPD_patient_summaries)))
writeLines(sprintf('The PQ failure rate using the old mean estimates is %s%% in %s individuals',
                   round(P_Failure_old_mean, 6), nrow(BPD_patient_summaries)))
writeLines(sprintf('The PQ failure rate using the new genetic model is %s%% in %s individuals',
                   round(P_Failure_new, 6), nrow(BPD_patient_summaries)))

# ==============================================================================
# Additional internal check using Summary_data_ModelResults.RData
# ==============================================================================
load("~/Documents/RecurrentVivax/RData/Summary_data_ModelResults.RData")
sum(Summary_data[grepl("BPD", Summary_data$patientid), "Failure"])/655
ind <- Summary_data$patientid %in% BPD_patient_summaries$patientid
unique(Summary_data$Failure[ind] - BPD_patient_summaries$Failure_old_median)

# ==============================================================================
# Aside: Summary of recurrences without genetic-based estimates
# ==============================================================================
episode_count_per_pid <- table(Combined_Time_Data_BPD$patientid)
pids_recur <- names(episode_count_per_pid)[episode_count_per_pid > 1]
ind_recur <- BPD_patient_summaries$patientid %in% pids_recur
BPD_patient_summaries$recur <- 0
BPD_patient_summaries$recur[ind_recur] <- 1
nrecur <- sum(BPD_patient_summaries$recur)
ntotal <- nrow(BPD_patient_summaries)
nrmiss <- sum(BPD_patient_summaries$Failure_gen == 0 & BPD_patient_summaries$recur == 1)
writeLines(sprintf("Of %s patients who recurred, there are %s without a genetic-based estimate
                   (%s%% of all %s patients, %s%% of all %s patients who recurred)",
                   nrecur, nrmiss,
                   100*round(nrmiss/ntotal,3), ntotal,
                   100*round(nrmiss/nrecur,3), nrecur))

# The entries without genetic-based estimates:
BPD_patient_summaries[BPD_patient_summaries$Failure_gen == 0 & BPD_patient_summaries$recur == 1,]
# [1] "recurrent missing for BPD_150"
# [1] "recurrent missing for BPD_453"
# [1] "enrolment missing for BPD_564"
# [1] "recurrent missing for BPD_564" - only episode 2 available
# BPD_477 has no genetic data:
load('~/Documents/RecurrentVivax/RData/GeneticModel/MS_data_PooledAnalysis.RData')
"BPD_477" %in% MS_pooled$ID


