#################################################################################
# PQ failure rates: sum(per-person probabilities of any failure) / people, where
# people are all PQ treated, and the per-person probability of any failure is 1
# minus the product of reinfection. Note that estimates based on time-to-event
# only are used where genetically informed estimates are not available and for
# censored observations.
#
# Old results: 3% for BPD PQ treated (all BPD patients), 2.4% for VHX PQ
# treated, 2.9% for BPD plus VHX PQ treated, based on median. Specifically,
# 3.047353 for BPD computed on line 2008 of Pooled_Analysis.Rmd, based on the
# median reinfection probability (see lines 1791 and 1792).
#
# We focus on BPD only here, because VHX genetic-based estimates require
# paired-episode post-hoc analysis. The code is based on Pooled_Analysis.Rmd but
# it differs (see notes below). Run this after Compare_recurrent_state.R.
#
# Because genetic data on BPD study participants were all analysed jointly under
# the prototype, for BPD failure rate computations using the old results, we can
# compute an estimate using both the old median and mean (they are not equal -
# see plots in Extract_and_plot_prototype.R). Besides supplementary figure 9,
# almost all figures and computations in Pooled_Analysis.Rmd and thus the
# Taylor&Watson 2019 are based on the median. This includes the PQ failure rate
# computations. The re-estimate based on the old median is used to internally
# check failure rate computation. The re-estimate based on the old mean is
# computed to see how old-median vs old-mean compares with old-median vs
# new-mean. The statistical genetic focus of the re-analysis does not merit the
# heavy computation required for a new median.
# 
# Note that new results also differ to old ones because they use slightly
# different allele frequencies, and the time-to-event posterior estimates
# plugged into the prototype were un-normalised.
################################################################################
rm(list = ls())

# Load VHX and BPD pooled non-genetic data set and convert to data frame
load('~/Documents/RecurrentVivax/RData/TimingModel/Combined_Time_Event.RData')

# Remove enrolment episodes, add episode ids
Combined_Time_Data <- as.data.frame(Combined_Time_Data)
Combined_Time_Data <- Combined_Time_Data[Combined_Time_Data$episode > 1, ]
Combined_Time_Data$episodeid <- paste(Combined_Time_Data$patientid,
                                          Combined_Time_Data$episode, sep = "_")

# Extract reinfection probabilities for all recurrences and censored rows.
# N.B. censored rows have pseudo episode numbers and "1" under censored.
Combined_Time_Data$I_prototype_median <- NA
Combined_Time_Data$I_prototype_mean <- NA
Combined_Time_Data$I_Pv3Rs <- NA
Combined_Time_Data$I_gen <- 0 # Genetic info available indicator

# Load genetic-based median estimates for all analysed by prototype (jointly or pairwise)
load("../Rdata/MS_final_generated_by_running_all_chunks_of_Pooled_Analysis.Rmd")
rownames(MS_final) <- MS_final[,"Episode_Identifier"]

# Load genetic-based median and mean estimates for for all analysed jointly by prototype
path <- "~/Documents/RecurrentVivax" # Path to old estimates
load(sprintf('%s/RData/GeneticModel/Including_Complex_Cases_Full_Posterior_Model_samples.RData', path))

# Check median estimates agree where overlap
all(MS_final[row.names(thetas_9MS), "I_median"] == thetas_9MS[, "I50%"], na.rm = T)

# Extract genetic based estimates generated by the prototype
prototype_median <- MS_final$I_median
prototype_mean <- thetas_9MS[rownames(MS_final), "I"] 
names(prototype_median) <- names(prototype_mean) <- rownames(MS_final)

# NB that theta_9MS contains rows for pids whose enrolment and first recurrence MOIs sum to six:
rownames(thetas_9MS)[which(!rownames(thetas_9MS) %in% rownames(MS_final))]

# Check mean estimates were extracted correctly; na.rm needed because of pids mentioned above
all(prototype_mean[rownames(thetas_9MS)] == thetas_9MS[, "I"], na.rm = T)

# Load Pv3R results
load("../RData/marg_results_Pv3Rs.RData") 

# Collect prototype and Pv3Rs results within a single data frame
if(!all(names(prototype_mean) == names(prototype_median))) stop ("Problem with eids")
Results <- data.frame(Pv3Rs = TimeToEvent_Pv3Rs[names(prototype_median),"I"], 
                          prototype_median, 
                          prototype_mean)

# Load time-to-event only based estimates (used when genetic ones unavailable)
# These are all posterior mean estimates (Pooled_Analysis.Rmd lines 672 and 1807)
# N.B. prior_estimates.RData is generated by Compute_recurrent_states_Pv3Rs.R
load("../RData/prior_estimates.RData")
# Check prior row names are the same ahead of for loop below
if (!all(rownames(prior_unnorm) == rownames(prior))) stop("prior row-name mismatch")

# ==============================================================================
# Populate Combined_Time_Data in order to compute failure rates
# ==============================================================================
# Replace NA with genetic-based estimate where available; use time-to-event
# otherwise (includes all censored rows). N.B. BPD_634_3 and BPD_68_4 are
# missing time-to-event estimates. N.B. In Pool_Analysis.Rmd, probabilities are
# stored in rows for episode 1 to final recurrences ("we look one episode ahead"
# - line 1787). Here, probabilities are stored in rows for initial recurrence to
# censored row.
for(i in 1:nrow(Combined_Time_Data)){

  eid <- Combined_Time_Data$episodeid[i]

  if (eid %in% rownames(Results)) { # Use genetic episode if available
    j <- which(rownames(Results) == eid)
    Combined_Time_Data$I_prototype_median[i] <- Results$prototype_median[j]
    Combined_Time_Data$I_prototype_mean[i] <- Results$prototype_mean[j]
    Combined_Time_Data$I_Pv3Rs[i] <- Results$Pv3Rs[j]
    Combined_Time_Data$I_gen[i] <- 1 # Make a note that genetic-based
  } else if (eid %in% rownames(prior)) { # Needed because BPD_634_3 and BPD_68_4 are missing
    j <- which(rownames(prior) == eid)
    # Use un-normalised for median because median used for internal check.
    Combined_Time_Data$I_prototype_median[i] <- prior_unnorm$I[j]
    Combined_Time_Data$I_prototype_mean[i] <- prior$I[j]
    Combined_Time_Data$I_Pv3Rs[i] <- prior$I[j]
  }
}

# FYI, among people without recurrences, early drop outs have higher failure estimates
No_recurrence_logs <- !Combined_Time_Data$episodeid %in% rownames(Results)
No_recurrence_eids <- Combined_Time_Data$episodeid[No_recurrence_logs]
plot(x = Combined_Time_Data[No_recurrence_logs, "Time_to_event"],
     y = 1-prior[No_recurrence_eids, "I"], pch = 4, 
     col = grepl("PMQ", Combined_Time_Data$arm_num[No_recurrence_logs]) + 2)
legend("right", legend = c("no PMQ", "PMQ+"), fill = (0:1)+2, bty = "n")

# Create a per-patient summary data frame (remove episode-level summaries to
# avoid confusion - should have done this in Pooled_Analysis.Rmd)
patient_summaries = Combined_Time_Data[!duplicated(Combined_Time_Data$patientid),
                                               c("patientid", "arm_num", "FU_time")]
patient_summaries$Failure_prototype_median <- NA
patient_summaries$Failure_prototype_mean <- NA
patient_summaries$Failure_Pv3Rs <- NA
patient_summaries$Failure_gen <- NA
 

# Compute PQ failure probabilities
for(i in 1:nrow(patient_summaries)){
  pid = patient_summaries$patientid[i]
  ind = which(pid == Combined_Time_Data$patientid)
  patient_summaries$Failure_prototype_median[i] <- 1-prod(Combined_Time_Data[ind, "I_prototype_median"], na.rm = T)
  patient_summaries$Failure_prototype_mean[i] <- 1-prod(Combined_Time_Data[ind, "I_prototype_mean"], na.rm = T)
  patient_summaries$Failure_Pv3Rs[i] <- 1-prod(Combined_Time_Data[ind, "I_Pv3Rs"], na.rm = T)
  patient_summaries$Failure_gen[i] <- sum(Combined_Time_Data[ind, "I_gen"])
}

# ==============================================================================
# Recompute point estimate, checking prototype_mean one agrees with Pooled_Analysis
# (internal control). Specifically, Failure 3.047353 computed on line 2008 of
# Pooled_Analysis.Rmd, based on the median reinfection probability (see lines
# 1791 and 1792, where Combined_Time_Data$Reinfection_Probability[i] =
# MS_final$I_median[MS_final$Episode_Identifier==MS_id])
# ==============================================================================

ind_all <- grepl("PMQ", patient_summaries$arm_num)
ind_BPD <- grepl("PMQ", patient_summaries$arm_num) & grepl("BPD", patient_summaries$patientid)
ind_VHX <- grepl("PMQ", patient_summaries$arm_num) & grepl("VHX", patient_summaries$patientid)
  
Failure_prototype = 100*sum(patient_summaries$Failure_prototype_median[ind_all], na.rm = T)/sum(ind_all)
Failure_Pv3Rs = 100*sum(patient_summaries$Failure_Pv3Rs[ind_all], na.rm = T)/sum(ind_all)

Failure_prototype_VHX = 100*sum(patient_summaries$Failure_prototype_median[ind_VHX], na.rm = T)/sum(ind_VHX)
Failure_Pv3Rs_VHX = 100*sum(patient_summaries$Failure_Pv3Rs[ind_VHX], na.rm = T)/sum(ind_VHX)

Failure_prototype_BPD_median = 100*sum(patient_summaries$Failure_prototype_median[ind_BPD], na.rm = T)/sum(ind_BPD)
Failure_prototype_BPD_mean = 100*sum(patient_summaries$Failure_prototype_mean[ind_BPD], na.rm = T)/sum(ind_BPD)
Failure_Pv3Rs_BPD = 100*sum(patient_summaries$Failure_Pv3Rs[ind_BPD], na.rm = T)/sum(ind_BPD)


# New mean estimates give the same failure rate as old median estimates: new
# model just not change the scientific conclusion of Taylor&Watson et al. 2019
writeLines(sprintf('The PQ failure rate re-estimated using the old median estimates is %s%% in %s individuals',
                   round(Failure_prototype_median, 6), nrow(BPD_patient_summaries)))
writeLines(sprintf('The PQ failure rate estimated using the old mean estimates is %s%% in %s individuals',
                   round(Failure_prototype_mean, 6), nrow(BPD_patient_summaries)))
writeLines(sprintf('The PQ failure rate estimated using the new genetic model is %s%% in %s individuals',
                   round(Failure_Pv3Rs, 6), nrow(BPD_patient_summaries)))

# ==============================================================================
# Additional internal check using Summary_data_ModelResults.RData
# ==============================================================================
load("~/Documents/RecurrentVivax/RData/Summary_data_ModelResults.RData")
sum(Summary_data[grepl("BPD", Summary_data$patientid), "Failure"])/655
ind <- Summary_data$patientid %in% BPD_patient_summaries$patientid
unique(Summary_data$Failure[ind] - BPD_patient_summaries$Failure_prototype_median)

# ==============================================================================
# Aside: Summary of recurrences without genetic-based estimates
# ==============================================================================
episode_count_per_pid <- table(Combined_Time_Data_BPD$patientid)
pids_recur <- names(episode_count_per_pid)[episode_count_per_pid > 1]
ind_recur <- BPD_patient_summaries$patientid %in% pids_recur
BPD_patient_summaries$recur <- 0
BPD_patient_summaries$recur[ind_recur] <- 1
nrecur <- sum(BPD_patient_summaries$recur)
ntotal <- nrow(BPD_patient_summaries)
nrmiss <- sum(BPD_patient_summaries$Failure_gen == 0 & BPD_patient_summaries$recur == 1)
writeLines(sprintf("Of %s patients who recurred, there are %s without a genetic-based estimate
                   (%s%% of all %s patients, %s%% of all %s patients who recurred)",
                   nrecur, nrmiss,
                   100*round(nrmiss/ntotal,3), ntotal,
                   100*round(nrmiss/nrecur,3), nrecur))

# The entries without genetic-based estimates:
BPD_patient_summaries[BPD_patient_summaries$Failure_gen == 0 & BPD_patient_summaries$recur == 1,]
# [1] "recurrent missing for BPD_150"
# [1] "recurrent missing for BPD_453"
# [1] "enrolment missing for BPD_564"
# [1] "recurrent missing for BPD_564" - only episode 2 available
# BPD_477 has no genetic data:
load('~/Documents/RecurrentVivax/RData/GeneticModel/MS_data_PooledAnalysis.RData')
"BPD_477" %in% MS_pooled$ID


